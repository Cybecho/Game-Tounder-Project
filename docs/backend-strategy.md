# 🌐 백엔드 전략 및 랭킹 시스템 구축 가이드

## 1. 개요

이 문서는 현재 클라이언트 사이드에서만 실행되는 게임에 **온라인 랭킹 시스템**을 도입하기 위한 최적의 서버리스 백엔드 솔루션을 선정하고, 그 구체적인 실행 계획을 수립하는 것을 목표로 합니다.

- **현 상태:** 모든 게임 로직은 클라이언트(`js/game.js`)에 집중되어 있으며, 별도의 서버나 데이터베이스가 없는 순수 정적(static) 웹 애플리케이션입니다.
- **목표:** 사용자의 최종 점수를 기록하고, 모든 사용자가 볼 수 있는 Top 10 랭킹 보드를 제공하는 백엔드 시스템을 구축합니다.

## 2. 백엔드 요구사항 분석

성공적인 백엔드 솔루션을 선택하기 위해, 현재 프로젝트의 핵심적인 기술적, 비즈니스적 요구사항을 다음과 같이 정의합니다.

1.  **단순한 데이터 처리:** 백엔드의 역할은 `(플레이어 이름, 점수)` 데이터를 받아 저장(Write)하고, 점수 기준으로 정렬된 목록을 제공(Read)하는 매우 명확하고 단순한 작업에 한정됩니다.
2.  **관계형 데이터에 대한 강점:** 랭킹 데이터는 '점수'를 기준으로 내림차순 정렬(`ORDER BY score DESC`)하고 상위 N개(`LIMIT 10`)를 가져오는 작업이 핵심입니다. 이는 관계형 데이터베이스(SQL)가 NoSQL에 비해 훨씬 직관적이고 효율적으로 처리할 수 있는 작업입니다.
3.  **비용 효율성:** 개인 프로젝트이거나 소규모 팀에서 운영하는 것을 가정하므로, 초기 비용이 없거나 매우 저렴해야 합니다. 또한, 게임이 예상치 못하게 인기를 끌었을 때 트래픽 증가로 인한 비용이 예측 가능하고 통제 가능해야 합니다.
4.  **빠른 개발 및 통합 속도:** 현재 프로젝트가 단일 파일 기반으로 빠르게 개발된 만큼, 백엔드 역시 복잡한 인프라 설정 없이 기존 코드베이스에 쉽게 통합될 수 있어야 합니다.
5.  **낮은 지연 시간 (Low Latency):** 플레이어가 게임을 마친 후 점수를 등록하거나 랭킹 보드를 조회할 때, 응답이 느리면 사용자 경험이 크게 저하됩니다. 따라서 빠른 응답 속도를 보장하는 것이 중요합니다.

## 3. 서버리스 백엔드 솔루션 비교 분석

위 요구사항을 바탕으로, 4가지 주요 서버리스 플랫폼을 심층 비교 분석했습니다.

| 항목 | Firebase | Vercel (+Postgres) | Render (+Postgres) | Cloudflare Workers (+D1) |
| :--- | :--- | :--- | :--- | :--- |
| **주요 모델** | 완전 관리형 BaaS | 프론트엔드 최적화 PaaS | 풀스택/컨테이너 PaaS | **엣지 컴퓨팅** |
| **데이터베이스** | NoSQL (Firestore) | SQL (Postgres) | SQL (Postgres) | **SQL (D1, SQLite 기반)** |
| **개발 편의성** | **매우 높음** | 높음 | 중간 | 중간 |
| **비용 구조** | 사용량 기반 (Read/Write) | 사용량 기반 | **자원 기반 (예측 가능)** | **매우 저렴 (관대함)** |
| **성능 (지연시간)** | 빠름 | 빠름 | 안정적 | **가장 빠름 (엣지)** |
| **랭킹 기능 적합성**| 보통 | 높음 | 높음 | **매우 높음** |

### 4. 각 솔루션 심층 분석

#### 4.1. Firebase
- **한줄평:** 가장 빠른 프로토타이핑 도구이지만, 장기적인 비용 리스크가 존재.
- **장점:** 개발 속도가 압도적으로 빠르고, 실시간 기능 구현이 매우 쉽습니다.
- **단점:** 랭킹 보드처럼 읽기(Read) 작업이 빈번한 기능의 경우, 사용량 기반 요금제가 예기치 않은 비용 급증으로 이어질 수 있습니다. 또한 NoSQL 기반이라 SQL처럼 정교한 순위 쿼리가 다소 번거롭습니다.

#### 4.2. Vercel (+ Vercel Postgres)
- **한줄평:** 프론트엔드 배포와 백엔드 기능의 완벽한 조화.
- **장점:** 현존 최고의 프론트엔드 배포/전송(CDN) 성능을 제공하며, 서버리스 함수와 관리형 Postgres 데이터베이스를 매우 쉽게 프로젝트에 통합할 수 있습니다.
- **단점:** Render에 비해 비용 예측이 조금 더 어렵고, 플랫폼 자체가 백엔드보다는 프론트엔드에 더 무게를 두고 있습니다.

#### 4.3. Render (+ Render Postgres)
- **한줄평:** 예측 가능하고 안정적인 비용이 최우선일 때 가장 합리적인 선택.
- **장점:** 월 단위 자원(CPU, RAM) 기반 요금제라 트래픽이 아무리 많아져도 비용이 고정됩니다. Docker를 지원하여 백엔드 환경의 유연성과 제어권이 높습니다.
- **단점:** Vercel이나 Cloudflare에 비해 초기 설정이 다소 필요하며, 글로벌 엣지 네트워크 기반의 프론트엔드 전송 속도는 상대적으로 약합니다.

#### 4.4. Cloudflare Workers (+ Cloudflare D1)
- **한줄평:** 최고의 성능과 최고의 비용 효율성을 동시에 제공하는, 현재 프로젝트에 가장 이상적인 솔루션.
- **장점:**
    - **성능:** 전 세계에 분산된 엣지 로케이션에서 코드를 실행하므로, 사용자와 물리적으로 가장 가까운 곳에서 API 요청을 처리하여 응답 속도가 타의 추종을 불허합니다.
    - **비용:** 무료 제공량이 매우 관대하여 사실상 비용이 발생하지 않을 확률이 높으며, 유료 플랜 역시 매우 저렴합니다.
    - **기술 적합성:** 서버리스 SQL 데이터베이스인 D1은 랭킹 쿼리에 완벽하게 부합합니다.
- **단점:** D1과 같은 서비스가 비교적 최신 기술이라 생태계나 관련 자료가 다른 플랫폼만큼 풍부하지 않을 수 있으며, '엣지'라는 개발 패러다임에 대한 약간의 학습이 필요합니다.

## 5. 최종 추천: Cloudflare Workers + D1

**결론적으로, 이 프로젝트의 랭킹 시스템 구축을 위한 백엔드 솔루션으로 Cloudflare Workers와 D1 데이터베이스 조합을 가장 강력하게 추천합니다.**

### 선정 이유
- **최상의 사용자 경험:** 엣지 컴퓨팅을 통해 구현된 낮은 지연 시간의 API는 플레이어에게 가장 빠르고 쾌적한 랭킹 조회 및 등록 경험을 선사할 것입니다.
- **압도적인 비용 효율성:** 관대한 무료 플랜은 프로젝트의 초기 부담을 완전히 없애주며, 향후 트래픽이 증가하더라도 가장 저렴하게 서비스를 운영할 수 있습니다.
- **완벽한 기술 스택:** 단순하고 명확한 랭킹 데이터 구조는 Cloudflare D1(SQL 기반)으로 처리하기에 최적이며, 간단한 API 로직은 Cloudflare Worker로 구현하기에 전혀 무리가 없습니다.

## 6. Cloudflare 기반 랭킹 시스템 구축 계획

다음은 Cloudflare를 사용하여 랭킹 시스템을 실제로 구축하는 단계별 계획입니다.

### 1단계: Cloudflare 환경 설정
1.  Cloudflare 계정을 생성합니다.
2.  Node.js 환경에서 `npm install -g wrangler` 명령어로 Cloudflare의 CLI 도구인 Wrangler를 설치합니다.
3.  `wrangler login` 명령어로 계정에 로그인합니다.

### 2단계: D1 데이터베이스 생성 및 스키마 정의
1.  `wrangler d1 create <DB_NAME>` 명령어로 랭킹을 저장할 D1 데이터베이스를 생성합니다.
2.  다음과 같은 SQL을 사용하여 `scores` 테이블을 정의하는 마이그레이션 파일을 작성합니다.
    ```sql
    -- migrations/0001_create_scores_table.sql
    CREATE TABLE scores (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      player_name TEXT NOT NULL,
      score INTEGER NOT NULL,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    -- 점수 기준 내림차순 인덱스 생성 (조회 성능 향상)
    CREATE INDEX idx_scores_on_score_desc ON scores (score DESC);
    ```
3.  `wrangler d1 execute <DB_NAME> --file=./migrations/0001_create_scores_table.sql` 명령어로 데이터베이스에 테이블을 생성합니다.

### 3단계: Cloudflare Worker API 개발
1.  `wrangler init <WORKER_NAME>` 명령어로 Worker 프로젝트를 초기화합니다.
2.  `wrangler.toml` 파일에 D1 데이터베이스 바인딩을 추가하여 Worker가 D1에 접근할 수 있도록 설정합니다.
3.  Worker 코드(`index.js`)에 두 개의 API 엔드포인트를 구현합니다.

    - **점수 등록 API (`POST /api/scores`):**
      - 요청 본문에서 `player_name`과 `score`를 파싱합니다.
      - 유효성 검사(이름 길이, 점수 타입 등)를 수행합니다.
      - D1 데이터베이스에 `INSERT` 쿼리를 실행하여 점수를 저장합니다.

    - **랭킹 조회 API (`GET /api/leaderboard`):**
      - D1 데이터베이스에 `SELECT player_name, score FROM scores ORDER BY score DESC LIMIT 10` 쿼리를 실행합니다.
      - 조회된 결과를 JSON 형태로 클라이언트에 반환합니다.

### 4단계: 게임 클라이언트와 API 연동
1.  **점수 등록 로직 (`GameOverScene`):**
    - `gameOver()` 함수가 호출될 때, 최종 점수(`this.finalStats.score`)와 플레이어 이름(입력받는 UI 추가 필요)을 가져옵니다.
    - `fetch('/api/scores', { method: 'POST', ... })`를 사용하여 개발된 Worker API로 점수 데이터를 전송합니다.
2.  **랭킹 조회 로직 (신규 UI):**
    - 메인 메뉴나 게임오버 화면에 '랭킹 보기' 버튼을 추가합니다.
    - 버튼 클릭 시, `fetch('/api/leaderboard')`를 호출하여 랭킹 데이터를 가져옵니다.
    - 받아온 데이터를 기반으로 순위, 플레이어 이름, 점수를 표시하는 UI를 동적으로 생성합니다.
