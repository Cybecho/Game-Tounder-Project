# 🏗️ 게임 아키텍처 문서

## 1. 전체 아키텍처 개요

이 게임은 **Phaser.js 3** 프레임워크를 기반으로 한 2D 탑다운 슈팅 게임입니다. 핵심 아키텍처는 **Scene 기반 상태 관리**와 **동적 시스템 모듈화**에 중점을 두고 있습니다. 게임의 흐름은 `GameScene`과 `GameOverScene`이라는 두 개의 주요 Scene에 의해 제어됩니다.

### 아키텍처 다이어그램

```
+-----------------+      +-----------------+
|   GameScene     |----->|  GameOverScene  |
| (메인 게임 로직) |      | (결과 및 재시작) |
+-----------------+      +-----------------+
        |
        | (포함 관계)
        v
+-----------------------------------------+
|           모듈화된 게임 시스템            |
|-----------------------------------------|
| 🏃‍♂️ 대쉬 시스템 (순간이동, 쿨다운)      |
| 🎯 자동 조준 및 무기 시스템             |
| 👹 적 AI 및 스폰 시스템 (엘리트 포함)   |
| 💥 물리 기반 넉백 시스템                |
| 🔮 아이템 시스템 (도망가는 AI)          |
| 📈 동적 난이도 조절 시스템              |
| 🎨 UI/UX 및 시각 효과 시스템            |
| 🔄 게임 상태 관리 및 초기화 시스템      |
+-----------------------------------------+
```

## 2. 📁 파일 구조

```
TEST-GAME/
├── index.html          # 게임의 HTML 진입점
├── js/
│   └── game.js         # 핵심 게임 로직 (GameScene, GameOverScene)
├── server.js           # 개발용 Node.js HTTP 서버
├── package.json        # 프로젝트 의존성 및 스크립트
├── README.md           # 프로젝트 개요 및 사용자 가이드
└── docs/               # 심층 기술 문서
    ├── architecture.md # 현재 파일: 시스템 아키텍처
    ├── systems.md      # 각 게임 시스템의 상세 설계
    └── api.md          # 클래스 및 함수 API 레퍼런스
```

## 3. 🏛️ 핵심 클래스 구조

### `GameScene` 클래스
`Phaser.Scene`을 상속받는 이 클래스는 게임의 심장입니다. 모든 게임 플레이 로직, 상태, 오브젝트 관리가 이곳에서 이루어집니다.

- **주요 역할:** 게임 월드 생성, 플레이어 및 NPC 관리, 물리 및 충돌 처리, 사용자 입력 감지, 게임 루프 실행.
- **핵심 메서드:**
    - `initializeGameVariables()`: 게임 재시작 시 모든 상태 변수를 완벽하게 리셋합니다.
    - `preload()`: 모든 게임 에셋을 **코드를 통해 절차적으로 생성**하고 로드합니다.
    - `create()`: 게임 오브젝트, UI, 충돌 규칙, 타이머 등 초기 월드를 구성합니다.
    - `update(time, delta)`: 매 프레임 게임의 동적 로직(이동, 발사, AI 등)을 실행합니다.

### `GameOverScene` 클래스
플레이어의 체력이 0이 되었을 때 활성화되는 Scene입니다.

- **주요 역할:** 최종 게임 통계(점수, 생존 시간 등) 표시, 사용자에게 게임 재시작 옵션 제공.

## 4. 🎨 렌더링 및 에셋 아키텍처

### 100% 절차적 SVG 에셋
이 게임은 외부 이미지 파일을 전혀 사용하지 않습니다. 모든 시각적 에셋(플레이어, 적, 아이템, 이펙트 등)은 `preload` 단계에서 **SVG 문자열을 통해 동적으로 생성**됩니다. `encodeURIComponent`를 사용하여 SVG 데이터를 안전하게 인코딩하고 Phaser의 텍스처 관리자에 등록합니다.

```javascript
// 예시: 플레이어 캐릭터 생성
this.load.image('player', 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
    <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
        <circle cx="16" cy="16" r="12" fill="#4CAF50" stroke="#2E7D32" stroke-width="2"/>
    </svg>
`));
```

- **장점:**
    - **경량성:** HTTP 요청 수를 줄이고 로딩 시간을 단축합니다.
    - **유연성:** 코드 내에서 쉽게 에셋의 색상, 모양, 크기를 변경할 수 있습니다.
    - **확장성:** 벡터 기반이므로 어떤 해상도에서도 깨끗하게 렌더링됩니다.

### 월드 좌표계와 카메라
- **거대한 월드:** 게임은 8000x6000 픽셀의 광활한 월드에서 진행됩니다.
- **추적 카메라:** 카메라는 항상 플레이어를 따라다니며, `lerp`(선형 보간) 값을 설정하여 부드러운 추적 효과를 구현했습니다.
- **UI 레이어:** 모든 UI 요소는 `setScrollFactor(0)`을 통해 카메라의 움직임에 영향을 받지 않고 화면에 고정됩니다.

## 5. 🔄 게임 루프 및 상태 관리

### Phaser 게임 루프
Phaser의 내장 게임 루프(`preload` -> `create` -> `update`)를 충실히 따릅니다. `update` 메서드 내에서는 각 시스템에 해당하는 메서드들(`movePlayer`, `moveEnemies`, `fireWeapon` 등)을 순차적으로 호출하여 코드의 가독성과 모듈성을 확보했습니다.

### 중앙 집중식 상태 관리
모든 게임 상태(점수, 체력, 레벨 등)는 `GameScene`의 프로퍼티로 직접 관리됩니다. 이 방식은 중소 규모의 프로젝트에서 복잡한 상태 관리 라이브러리 없이 직관적인 데이터 흐름을 제공합니다.

- **상태 초기화:** `initializeGameVariables()` 메서드는 게임 시작 및 재시작 시 호출되어 모든 상태를 초기값으로 완벽하게 리셋합니다. 이는 게임 세션 간의 상태 오염을 방지하는 핵심적인 역할을 합니다.

## 6. 🧠 메모리 및 성능 최적화

- **오브젝트 풀링 (Group 사용):** Phaser의 `Group`을 사용하여 총알, 적 등 동적으로 생성/제거되는 오브젝트들을 효율적으로 관리합니다. 오브젝트가 화면 밖으로 나가거나 비활성화되면 `destroy()`를 호출하여 메모리에서 즉시 해제합니다.
- **효율적인 충돌 검사:** Phaser의 Arcade Physics 엔진은 내부적으로 쿼드트리(Quadtree)와 같은 공간 분할 기법을 사용하여, 오브젝트 수가 많아져도 충돌 검사 성능이 급격히 저하되지 않도록 합니다.
- **이벤트 리스너 자동 정리:** Scene이 멈추거나(`stop`) 재시작될 때, Phaser는 해당 Scene에 등록된 모든 이벤트 리스너와 타이머를 자동으로 정리하여 메모리 누수를 방지합니다.

이 아키텍처는 **단순함**, **유지보수성**, 그리고 **확장성** 사이의 균형을 맞추는 것을 목표로 설계되었습니다.
